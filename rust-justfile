# para justfile - Rust implementation testing



# Run Rust linting with clippy (all files or specific filter)
lint *FILTER:
    #!/bin/bash
    set -euo pipefail
    
    # Check if filter is provided using justfile variables
    if [ "{{FILTER}}" != "" ]; then
        echo "🔍 Running clippy for: {{FILTER}}"
        cargo clippy --all-targets --all-features -- -D clippy::correctness -D clippy::suspicious -W clippy::style -W clippy::complexity -W clippy::perf 2>&1 | grep -E "({{FILTER}}|error:|warning:)" || true
    else
        echo "🔍 Running clippy for all files..."
        cargo clippy --all-targets --all-features -- -D clippy::correctness -D clippy::suspicious -W clippy::style -W clippy::complexity -W clippy::perf
    fi

# Run tests with structured output for parsing (requires nextest or nightly rust)
test-structured:
    #!/bin/bash
    set -euo pipefail
    
    if command -v cargo-nextest >/dev/null 2>&1; then
        echo "▶ Running tests with nextest structured output..."
        cargo nextest run --message-format json-pretty
    else
        echo "▶ Install cargo-nextest for structured JSON output:"
        echo "  cargo install cargo-nextest"
        echo ""
        echo "▶ Falling back to cargo test with short format..."
        cargo test --message-format=short
    fi

# Install cargo-nextest for better test output
install-nextest:
    cargo install cargo-nextest


# Run Rust formatting check
fmt-check:
    cargo fmt --all -- --check

# Fix Rust formatting
fmt:
    cargo fmt --all

# Run all Rust checks (tests + linting + formatting) or specific test filter
test *FILTER:
    #!/bin/bash
    set -euo pipefail
    
    # Check if filter is provided using justfile variables
    if [ "{{FILTER}}" != "" ]; then
        echo "🧪 Running tests for: {{FILTER}}"
        
        if command -v cargo-nextest >/dev/null 2>&1; then
            cargo nextest run {{FILTER}}
        else
            cargo test {{FILTER}}
        fi
        exit 0
    fi
    
    echo "🧪 Running all Rust checks..."
    
    # Format first to ensure code is properly formatted
    printf "   Format: "
    if cargo fmt --all --quiet 2>/dev/null; then
        echo "✅ formatted"
    else
        echo "❌ formatting failed"
        exit 1
    fi
    
    # Test phase - try nextest first, fallback to cargo test
    printf "   Tests: "
    if command -v cargo-nextest >/dev/null 2>&1; then
        # Use nextest for better output formatting
        if test_output=$(cargo nextest run --status-level pass --final-status-level fail 2>&1); then
            # Parse nextest summary
            if echo "$test_output" | grep -q "Summary"; then
                summary=$(echo "$test_output" | grep "Summary" | tail -1)
                echo "✅ $(echo "$summary" | sed 's/.*Summary: //')"
            else
                echo "✅ passed"
            fi
        else
            echo "❌ FAILED"
            # Extract only actionable failure information
            echo "$test_output" | grep -E "^(FAIL|test .* \.\.\. FAILED)" 
            echo "$test_output" | grep -A1 -E "(assertion.*failed|panicked at)" | grep -v "^--$" | head -20
            exit 1
        fi
    else
        # Fallback to enhanced cargo test parsing
        if test_output=$(cargo test --message-format=short 2>&1); then
            # Extract test summary with better parsing
            if echo "$test_output" | grep -q "test result:"; then
                summary=$(echo "$test_output" | grep "test result:" | tail -1 | sed 's/test result: //')
                echo "✅ $summary"
            else
                echo "✅ passed"
            fi
        else
            echo "❌ FAILED"
            # Smart filtering: compile errors OR test failures
            if echo "$test_output" | grep -q "error\[E[0-9]\+\]"; then
                echo "=== COMPILE ERRORS ==="
                echo "$test_output" | grep -E "(error\[E[0-9]+\]|^ *\|)" | head -30
            else
                echo "=== TEST FAILURES ==="
                echo "$test_output" | grep -E "(test .* \.\.\. FAILED|assertion.*failed|panicked at|thread.*panicked)" | head -25
            fi
            exit 1
        fi
    fi
    
    # Clippy phase with simpler logic
    printf "   Linting: "
    if cargo clippy --all-targets --all-features -- -W clippy::all >/dev/null 2>&1; then
        echo "✅ clean"
    else
        echo "❌ FAILED"
        cargo clippy --all-targets --all-features -- -W clippy::all
        exit 1
    fi
    
    echo "🎉 All checks passed!"

# Run all Rust checks with verbose output
test-verbose:
    #!/bin/bash
    set -euo pipefail
    
    echo "🔍 Running verbose Rust checks..."
    
    echo "▶ Formatting code..."
    just fmt
    
    if command -v cargo-nextest >/dev/null 2>&1; then
        echo "▶ Running tests with nextest (verbose)..."
        cargo nextest run --verbose
    else
        echo "▶ Running tests with cargo test (verbose)..."
        cargo test -- --show-output
    fi
    
    echo "▶ Running linting..."
    just lint


# Build the Rust binary
build:
    cargo build

# Run the para binary with any arguments, ensuring it's built first
para *ARGS:
    just build
    ./target/debug/para {{ARGS}}

# Generic recipe to run any para subcommand - usage: just run <subcommand> [args...]
run *ARGS:
    just para {{ARGS}}

# Para subcommand aliases - these automatically forward to the para binary
start *ARGS:
    just para start {{ARGS}}

dispatch *ARGS:
    just para dispatch {{ARGS}}

finish *ARGS:
    just para finish {{ARGS}}

integrate *ARGS:
    just para integrate {{ARGS}}

cancel *ARGS:
    just para cancel {{ARGS}}

clean *ARGS:
    just para clean {{ARGS}}

list *ARGS:
    just para list {{ARGS}}

ls *ARGS:
    just para ls {{ARGS}}

resume *ARGS:
    just para resume {{ARGS}}

recover *ARGS:
    just para recover {{ARGS}}

continue *ARGS:
    just para continue {{ARGS}}

config *ARGS:
    just para config {{ARGS}}

completion *ARGS:
    just para completion {{ARGS}}

help *ARGS:
    just para help {{ARGS}}