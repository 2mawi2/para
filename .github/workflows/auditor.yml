name: Auditor - Technical Debt Analysis

on:
  schedule:
    - cron: '0 9 * * *'  # Once daily at 9 AM UTC
  workflow_dispatch:

jobs:
  analyze-codebase:
    runs-on: ubuntu-latest
    # Only allow 2mawi2 to trigger this workflow
    if: github.actor == '2mawi2'
    permissions:
      contents: read
      issues: write
      id-token: write
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Install just
        uses: extractions/setup-just@v2

      - name: Install and initialize qlty
        run: |
          # Install qlty non-interactively
          curl -sSL https://qlty.sh | bash
          
          # Export qlty path for this job
          echo "export PATH=\"$HOME/.qlty/bin:$PATH\"" >> $GITHUB_ENV
          export PATH="$HOME/.qlty/bin:$PATH"
          
          # Ensure .qlty is never committed
          if ! grep -q "^\.qlty/" .gitignore 2>/dev/null; then
            echo ".qlty/" >> .gitignore
          fi
          
          # Initialize qlty if not already done (answer no to both prompts)
          if [ ! -f ".qlty/qlty.toml" ]; then
            printf "n\nn\n" | $HOME/.qlty/bin/qlty init || true
          fi

      - name: Analyze codebase for technical debt
        uses: 2mawi2/claude-code-action-extended@main
        with:
          use_oauth: true
          model: "claude-sonnet-4-20250514"
          claude_access_token: ${{ secrets.CLAUDE_ACCESS_TOKEN }}
          claude_refresh_token: ${{ secrets.CLAUDE_REFRESH_TOKEN }}
          claude_expires_at: ${{ secrets.CLAUDE_EXPIRES_AT }}
          github_token: ${{ secrets.GITHUB_TOKEN }}
          direct_prompt: |
            You are a senior software architect focused on finding technical debt that impacts code maintainability and changeability.
            
            OBJECTIVE: Find real technical debt that makes the codebase hard to change, understand, or extend. Focus on issues that actually slow down development.
            
            SETUP PHASE:
            1. qlty should already be initialized from the workflow setup
            2. If you get "No qlty config found", run: printf "n\nn\n" | qlty init
            3. qlty is available in PATH - just use 'qlty' commands directly
            
            ANALYSIS WORKFLOW:
            1. Run: qlty smells --all --no-snippets
               - Look for "High total complexity" (count > 50)
               - Find "Deeply nested control flow" (level > 4)
               - Identify duplication with high mass scores (mass > 200)
               - Note functions with high complexity (count > 20)
            
            2. Run: qlty metrics --all --sort complexity --limit 20
               - Focus on files with complexity > 50
               - Check for files with > 300 LOC
               - Note classes with LCOM > 1 (indicates low cohesion)
               - Identify files with many functions (> 20)
            
            3. For the most complex files, run: qlty metrics --functions <file>
               - Find functions with cyclomatic complexity > 10
               - Identify functions > 50 lines
               - Look for functions with many parameters (> 5)
            
            4. Run: qlty metrics --all --max-depth 2
               - Identify modules/directories with high overall complexity
               - Find areas of the codebase that need architectural improvements
            
            PRIORITIZE THESE ISSUES (in order of impact):
            1. Massive code duplication (> 150 lines repeated across files)
            2. God classes/modules (files > 500 LOC with > 20 methods)
            3. Functions with cyclomatic complexity > 20
            4. Deeply nested code (nesting level > 4)
            5. Low cohesion (LCOM > 1) in large classes
            6. Long parameter lists (> 5 parameters)
            
            IGNORE THESE:
            - Simple unwrap() on static data or tests
            - TODO/FIXME comments
            - Performance optimizations
            - Generated code or external dependencies
            - Test files (unless they're > 1000 lines)
            - Minor naming issues
            
            CREATE 3-5 ISSUES:
            - Focus on different types of debt (don't create 5 duplication issues)
            - Prioritize by impact on development velocity
            - Each issue should be actionable with clear refactoring steps
            
            For each issue, create a JSON file in .github-issues/ with:
            - Clear title describing the maintainability problem
            - Detailed body explaining:
              * Current metrics (complexity, LOC, duplication mass, etc.)
              * Why this slows down development
              * Concrete refactoring approach
              * Expected improvement in metrics
            
            CLEANUP: After analysis, run: rm -rf .qlty/
          allowed_tools: "Edit,Read,Write,MultiEdit,Glob,Grep,LS,TodoRead,TodoWrite,Bash(just test),Bash(just test *),Bash(just lint),Bash(just status),Bash(cargo test),Bash(cargo test *),Bash(cargo clippy),Bash(cargo clippy *),Bash(git log),Bash(git log *),Bash(git blame),Bash(git shortlog),Bash(rg),Bash(grep),Bash(find),Bash(wc),Bash(ls),Bash(cat),Bash(head),Bash(tail),Bash(printf \"n\\nn\\n\" | qlty init),Bash(qlty smells --all --no-snippets),Bash(qlty metrics --all --sort complexity --limit 20),Bash(qlty metrics --all --sort loc --limit 20),Bash(qlty metrics --all --max-depth 2),Bash(qlty metrics --all --max-depth 3),Bash(qlty metrics --functions *),Bash(rm -rf .qlty/)"
          timeout_minutes: "30"
          custom_instructions: |
            You have been granted comprehensive tools for analyzing codebases for technical debt that impacts maintainability:
            
            **Qlty Code Quality Tools (PRIMARY ANALYSIS TOOLS):**
            - `printf "n\nn\n" | qlty init` - Initialize qlty if needed (answers no to both prompts)
            - `qlty smells --all --no-snippets` - Find duplication, complexity, and code smells
              * Shows: complexity counts, nesting levels, duplication mass scores
              * Example: "High total complexity (count = 79)" or "Found 177 lines of similar code"
            - `qlty metrics --all --sort complexity --limit 20` - List most complex files
              * Shows: classes, functions, fields, cyclomatic complexity, LCOM, LOC
              * Focus on: complexity > 50, LOC > 300, LCOM > 1
            - `qlty metrics --functions <file>` - Analyze specific file's functions
              * Shows: per-function complexity and line counts
              * Look for: functions > 50 lines, complexity > 10
            - `qlty metrics --all --max-depth 2` - Module-level complexity analysis
              * Helps identify architectural issues
            - `rm -rf .qlty/` - Clean up qlty files after analysis
            
            **Traditional Analysis Tools:**
            - `just lint` - Run clippy for Rust-specific issues
            - `just test` - Check test coverage
            - `rg` and `grep` - Search for specific patterns
            - `find`, `wc`, `ls` - File system analysis
            - Git commands - History and blame analysis
            
            **File Manipulation:**
            - Edit, Read, Write, MultiEdit - Examine code in detail
            - Glob, Grep, LS - Navigate codebase
            
            **Key Metrics to Focus On:**
            - Complexity > 50 = needs refactoring
            - Functions > 50 lines = violates single responsibility
            - Files > 300 LOC = poor module boundaries
            - Duplication mass > 200 = significant copy-paste
            - LCOM > 1 = low cohesion (unrelated responsibilities)
            - Nesting level > 4 = hard to understand
            
            **Analysis Workflow:**
            1. Initialize qlty first
            2. Use qlty smells to find major issues
            3. Use qlty metrics to quantify problems
            4. Drill down into specific files with functions analysis
            5. Create 3-5 diverse, high-impact issues
            6. Clean up .qlty directory when done
            
            Focus on technical debt that makes code hard to change, not theoretical issues.
      
      - name: Create GitHub issues from analysis
        if: always()
        env:
          GH_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}
        run: |
          echo "Checking for issues to create..."
          
          # Check if the issues directory exists
          if [ -d ".github-issues" ]; then
            echo "Found issues directory, processing..."
            
            # List files for debugging
            ls -la .github-issues/
            
            # Process each JSON file
            for issue_file in .github-issues/*.json; do
              if [ -f "$issue_file" ]; then
                echo "Processing $issue_file..."
                
                # Display file contents for debugging
                echo "File contents:"
                cat "$issue_file"
                
                # Extract title and body from JSON
                TITLE=$(jq -r '.title' "$issue_file")
                BODY=$(jq -r '.body' "$issue_file")
                
                # Check if title and body are valid
                if [ -n "$TITLE" ] && [ "$TITLE" != "null" ] && [ -n "$BODY" ] && [ "$BODY" != "null" ]; then
                  # Create the issue
                  echo "Creating issue: $TITLE"
                  ISSUE_URL=$(gh issue create \
                    --title "$TITLE" \
                    --body "$BODY" \
                    --label "technical-debt" \
                    --repo ${{ github.repository }})
                  
                  echo "Issue created successfully: $ISSUE_URL"
                  
                  # Extract issue number from URL
                  ISSUE_NUMBER=$(echo "$ISSUE_URL" | grep -oE '[0-9]+$')
                  
                  # Add @claude comment to trigger the PR assistant
                  echo "Adding @claude comment to issue #$ISSUE_NUMBER..."
                  gh issue comment "$ISSUE_NUMBER" \
                    --body "@claude please fix this technical debt issue" \
                    --repo ${{ github.repository }}
                  
                  echo "@claude comment added successfully"
                else
                  echo "Warning: Invalid JSON in $issue_file - skipping"
                fi
              fi
            done
          else
            echo "No issues directory found - the auditor may not have found any technical debt"
            echo "Current directory contents:"
            ls -la
          fi
      
      - name: Clean up qlty files
        if: always()
        run: |
          echo "Cleaning up qlty files..."
          rm -rf .qlty/ || true
          echo "Cleanup complete"